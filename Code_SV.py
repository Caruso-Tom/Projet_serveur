import numpy as npimport matplotlib.pyplot as ppimport pycuda.driver as cudaimport pycuda.autoinitfrom pycuda.compiler import SourceModuleimport time# Définition du domaine d'étudex_min = -10000x_max = 10000z_min = -10000z_max = 10000Tf = 10Nz = 66Nx = 66# Teste si Nz et Nx sont sous la bonne formeif (Nx - 2) % 32 == 0:    Nx += 32 - (Nx - 2) % 32if (Nz - 2) % 32 == 0:    Nz += 32 - (Nz - 2) % 32# Définition  de l'état initial en cudaU = np.zeros((Nz, Nx))  # Vitesse selon xU = U.astype(np.float32)U_gpu = cuda.mem_alloc(U.nbytes)cuda.memcpy_htod(U_gpu, U)V = np.zeros((Nz, Nx))  # Vitesse selon xV = V.astype(np.float32)V_gpu = cuda.mem_alloc(V.nbytes)cuda.memcpy_htod(V_gpu, V)Sigma_xx = np.zeros((Nz, Nx))  # Stress selon xxSigma_xx = Sigma_xx.astype(np.float32)Sigma_xx_gpu = cuda.mem_alloc(Sigma_xx.nbytes)cuda.memcpy_htod(Sigma_xx_gpu, Sigma_xx)Sigma_xz = np.zeros((Nz, Nx))  # Stress selon xzSigma_xz = Sigma_xz.astype(np.float32)Sigma_xz_gpu = cuda.mem_alloc(Sigma_xz.nbytes)cuda.memcpy_htod(Sigma_xz_gpu, Sigma_xz)Sigma_zz = np.zeros((Nz, Nx))  # Stress selon zzSigma_zz = Sigma_zz.astype(np.float32)Sigma_zz_gpu = cuda.mem_alloc(Sigma_zz.nbytes)cuda.memcpy_htod(Sigma_zz_gpu, Sigma_zz)# Définition des propriété du solVp = 3500  # Vitesse des ondes PVs = 1500  # Vitesse des ondes Srho = 10000  # DensitéB = np.ones((2 * Nz, Nx)) / rho  # Inverse de la densité (i,i+1/2,j,j+1/2)B = B.astype(np.float32)B_gpu = cuda.mem_alloc(B.nbytes)cuda.memcpy_htod(B_gpu, B)L = (rho * Vp ** 2 - 2 * rho * Vs ** 2) * np.ones((Nz, Nx))  # Coefficient Lambda (i+1/2,j)L = L.astype(np.float32)L_gpu = cuda.mem_alloc(L.nbytes)cuda.memcpy_htod(L_gpu, L)M = rho * Vs ** 2 * np.ones((2 * Nz, Nx))  # Coefficient Mu (i,i+1/2,j,j+1/2)M = M.astype(np.float32)M_gpu = cuda.mem_alloc(M.nbytes)cuda.memcpy_htod(M_gpu, M)# Définition des pas de disrétisationdz = np.float32((z_max - z_min) / (Nz - 1))dx = np.float32((x_max - x_min) / (Nx - 1))dt = np.float32(0.5 * dx / (np.sqrt(2) * Vp))Nt = int(Tf / dt) + 1# Coordonnées de la source et position approximative sur le maillagex_source = 0z_source = 0i_source = np.int32(int((x_source - x_min) / dx))j_source = np.int32(int((z_source - z_min) / dz))# Creating datasetX, Z = np.meshgrid(np.linspace(x_min, x_max, Nx), np.linspace(z_min, z_max, Nz))mod = SourceModule("""    #include <math.h>    __device__ float Dfx(float xn1,float xn, float dx)    {    float result=(xn1-xn)/dx;    return(result);    }    __device__ float Dfz(float xn1,float xn, float dz)    {    float result=(xn1-xn)/dz;    return(result);    }    __device__ float Source(float t,float dt)    {    float alpha =40.0;    float t0 = 5.0*t;    float result=-alpha * (t - t0) * exp(-alpha * (t - t0) * (t-t0));    return (result);    }    __global__ void stress_to_velocity(float *u, float *v, float *b, float *sigma_xx,    float *sigma_zz, float *sigma_xz, float dt, float dx, float dz)    {     int idx = (threadIdx.x+1) +(blockIdx.x*blockDim.x)+ (threadIdx.y+1+(blockDim.y+2) * blockIdx.y) * (blockDim.x *gridDim.x+2);    u[idx] += b[2*idx]*dt*Dfx(sigma_xx[idx],sigma_xx[idx-1],dx)+b[2*idx]*dt*Dfz(sigma_xz[idx],sigma_xz[idx-(blockDim.x+2)],dz);    v[idx] += b[2*idx+1]*dt*Dfx(sigma_xz[idx],sigma_xz[idx-1],dx)+b[2*idx+1]*dt*Dfz(sigma_zz[idx],sigma_zz[idx-(blockDim.x+2)],dx);    }    __global__ void velocity_to_stress(float *u, float *v, float *l, float *m, int i_source, int j_source , float *sigma_xx,    float *sigma_zz, float *sigma_xz,float dt ,float dx,float dz, float t)    {     int idx = (threadIdx.x+1) +(blockIdx.x*blockDim.x)+ (threadIdx.y+1+(blockDim.y+2) * blockIdx.y) * (blockDim.x *gridDim.x+2);    int source=i_source+(blockDim.x *gridDim.x+2)*j_source;    sigma_xx[idx] += (l[idx]+2*m[2*idx+1])*dt*Dfx(u[idx+1],u[idx],dx)+l[idx]*dt*Dfz(v[idx+(blockDim.x+2)],v[idx],dz);    sigma_zz[idx] += (l[idx]+2*m[2*idx+1])*dt*Dfx(v[idx+1],v[idx],dz)+l[idx]*dt*Dfz(u[idx+(blockDim.x+2)],u[idx],dz);    sigma_xx[idx] += (m[2*idx+1])*dt*(Dfx(v[idx+1],v[idx],dx)+Dfz(u[idx+(blockDim.x+2)],u[idx],dz));    if (idx == source){        float excitation = Source(t,dt);        sigma_xx[idx] += dt * excitation;        sigma_zz[idx] += dt * excitation;    }    }""")# Définition des paramétres d'itération en tempsnt = 0t = np.float32(0)# Importation des fonctions cudastress_to_velocity = mod.get_function("stress_to_velocity")velocity_to_stress = mod.get_function("velocity_to_stress")longueur_grille_x = (Nx - 2) // 32 + 1longueur_grille_z = (Nz - 2) // 32 + 1while nt < Nt:    # Itération en temps    nt += 1    t += dt    # Calcul sur GPU    velocity_to_stress(U_gpu, V_gpu, L_gpu, M_gpu, i_source, j_source, Sigma_xx_gpu, Sigma_zz_gpu, Sigma_xz_gpu, dt, dx,                       dz, t, block=(32, 32, 1), grid=(longueur_grille_x, longueur_grille_z))    stress_to_velocity(U_gpu, V_gpu, B_gpu, Sigma_xx_gpu, Sigma_zz_gpu, Sigma_xz_gpu, dt, dx, dz, block=(32, 32, 1),                       grid=(longueur_grille_x, longueur_grille_z))    # Affichage en python    if nt % 10 == 0:        # On importe les résultats Cuda en python        cuda.memcpy_dtoh(U, U_gpu)        cuda.memcpy_dtoh(V, V_gpu)        cuda.memcpy_dtoh(Sigma_xx, Sigma_xx_gpu)        cuda.memcpy_dtoh(Sigma_xz, Sigma_xz_gpu)        cuda.memcpy_dtoh(Sigma_zz, Sigma_zz_gpu)        ax1 = pp.subplot(221)        # Affichage U        Umin = np.min(V)        Umax = np.max(U)        mylevelsU = np.linspace(Umin, Umax, 30)        ax1.contourf(X, Z, U, levels=mylevelsU, cmap="coolwarm")        ax1.set_title("U")        ax1.set_xlabel("x")        ax1.set_ylabel("z")        # Affichage V        ax2 = pp.subplot(222)        Vmin = np.min(V)        Vmax = np.max(V)        mylevelsV = np.linspace(Vmin, Vmax, 30)        ax2.contourf(X, Z, V, levels=mylevelsV, cmap="coolwarm")        ax2.set_title("V")        ax2.set_xlabel("x")        ax2.set_ylabel("z")        #   Affichage Sigma_xx        ax3 = pp.subplot(223)        Sigma_xx_min = np.min(Sigma_xx)        Sigma_xx_max = np.max(Sigma_xx)        mylevels_Sigma_xx = np.linspace(Sigma_xx_min, Sigma_xx_max, 30)        ax3.contourf(X, Z, Sigma_xx, levels=mylevels_Sigma_xx, cmap="coolwarm")        ax3.set_title("Sigma_xx")        ax3.set_xlabel("x")        ax3.set_ylabel("z")        # Affichage Sigma_zz        ax4 = pp.subplot(224)        Sigma_zz_min = np.min(Sigma_zz)        Sigma_zz_max = np.max(Sigma_zz)        mylevels_Sigma_zz = np.linspace(Sigma_zz_min, Sigma_zz_max, 30)        ax4.contourf(X, Z, Sigma_zz, levels=mylevels_Sigma_zz, cmap="coolwarm")        ax4.set_title("Sigma_zz")        ax4.set_xlabel("x")        ax4.set_ylabel("z")        pp.show()        pp.pause(1e-17)        time.sleep(0.5)        pp.close()print(0)